//  ћетод ’олецкого
int Chol(const matrix m, vector x,int n)
{
    matrix L;           //  нижн€€ диагональна€ матрица
    L = mal_mat(n);     //  выделение пам€ти

    //  получение нижней диагональной матрицы
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < i; j++)
        {
            for(int r = 0; r < j; r++)
                *(*(L+i) + j) += (*(*(L+i) + r))*(*(*(L+j) + r));
            *(*(L+i) + j) = (*(*(m+i) + j)- (*(*(L+i) + j)))/(*(*(L+j) + j));
        }
        for(int k = 0; k < i; k++)
            *(*(L+i) + i) += (*(*(L+i) + k))*(*(*(L+i) + k));
        *(*(L+i) + i) = sqrt(*(*(m+i) + i) - *(*(L+i) + i));
        *(*(L+i) + n) = *(*(m+i) + n);
    }
    //  printm(L,n);

    // решение Ly=b
    for(int i = 0; i < n; i++)
    {
        if(i != 0)  //  перва€ строка
        for(int j = 0; j <= n-i; j++)
            (*(*(L+i) + n)) -= (*(*(L+i) + j))*(*(x+j));
        *(x+i) = *(*(L+i) + n)/(*(*(L+i) + i));
    }

    // получение транспонированной матрицы
    for(int i = 0; i < n; i++)
    {
        for(int j = i+1; j < n; j++)
        {
            *(*(L+i) + j) = *(*(L+j) + i);
            *(*(L+j) + i) = 0;
        }
        *(*(L+i) + n) = *(x+i);
    }
    // printm(L,n);

    // –ешение Ltx = y
    for(int i = n-1; i>=0; i--)
    {
        if(i != n-1)  //  последн€€ строка
        for(int j = i+1; j<n; j++)
            (*(*(L+i) + n)) -= (*(*(L+i) + j))*(*(x+j));
        *(x+i) = *(*(L+i) + n)/(*(*(L+i) + i));
    }

    free_mat(L,n); // освобождение пам€ти матрицы L

    return 0;
}
